#! /usr/bin/env perl

use strict;
use Carp;
use File::Temp qw/tempfile tempdir/;
use Getopt::Long;

my $usage = <<"End_of_Usage";
Usage: $0 [options] walltime directory

Options:
       [-A allocation] [-c aprun_chunk] [--dry]
       [-N job_name] [-n num_processors] [-q queue]
       [-t num_threads_per_job] [--redo] 

End_of_Usage

my ($help, $alloc, $chunk, $dry, $name, $nproc, $nthread, $queue, $redo, $tmpdir);

GetOptions("h|help"    => \$help,
           "a|alloc=s" => \$alloc,
           "c|chunk=i" => \$chunk,
           "dry"       => \$dry,
           "n|np=i"    => \$nproc,
           "N|name=s"  => \$name,
           "q|queue=s" => \$queue, 
           "r|redo"    => \$redo,
           "t|nt=i"    => \$nthread,
	  ) or die("Error in command line arguments\n");

$help and die $usage;

$chunk ||= 1;
$name  ||= "cpar";

my $wall = shift @ARGV or die $usage;
my $dir  = shift @ARGV or die $usage;

-d $dir && !$redo and die "Directory '$dir' exists.\n\n$usage";
remove_dir($dir) if $redo;
verify_dir($dir);

my $cores_per_node = 24;

my @cmds = map { chomp; $_ } <STDIN>;

my $jobs_per_node = int($cores_per_node / $nthread);

my $i = 0;
while (@cmds && (!$nproc || $i < $nproc)) {
    $i++;
    my $jobfile = "$dir/node_p$i.sh";
    open(F, ">$jobfile") or die "Could not open $jobfile";
    print F "#!/bin/bash\n\n";
    print F 'time__="\nCommand: %C\n%Uuser %Ssystem %Eelapsed %PCPU (%Xtext+%Ddata %Mmax)k\n%Iinputs+%Ooutputs (%Fmajor+%Rminor)pagefaults %Wswaps\n"'."\n";
    print F "host__=`hostname`\n";
    print F 'echo $host__ "BEG> " `date`'."> time_p$i.txt\n\n";
    # print F "module swap PrgEnv-cray PrgEnv-gnu\n\n";

    for (my $j = 1; $j <= $jobs_per_node; $j++) {
        my $cmd = shift @cmds or last;
        # print F 'echo `printf "%q" '."'$cmd'`\n";
        print F "time -o time_p$i.txt -a". ' -f $time__'. " ($cmd) > log_p$i\_j$j.txt &\n\n";
    }

    print F "wait\n\n";
    print F 'echo $host__ "END> " `date`'."> time_p$i.txt\n";
    close(F);
    run("chmod a+x $jobfile");
}

chdir($dir);
my $tot = $i;
my $beg = 1;
my $k = 1;
while ($beg <= $tot) {

    my $end   = min($beg+$chunk-1, $tot);
    my $b_e   = $chunk > 1 ? "$beg-$end" : $beg;
    my $range = "$b_e/$tot";

    my $pbs   = "job$k.pbs";
    open(F, ">$pbs") or die "Could not open $pbs";
    print F "#!/bin/bash\n\n";

    print F "#PBS -l walltime=$wall\n";
    print F "#PBS -l mppwidth=24\n";
    print F "#PBS -N $name:$range\n";
    print F "#PBS -e $name-$b_e.".'$PBS_JOBID.err'."\n";
    print F "#PBS -o $name-$b_e.".'$PBS_JOBID.out'."\n\n";
    print F 'cd $PBS_O_WORKDIR'."\n\n";

    if ($chunk > 1) {
        for (my $i = $beg; $i <= $end; $i++) {
            print F "aprun ./node_p$i.sh &\n";
        }
        print F "\nwait\n";
    } else {
        print F "aprun ./node_p$beg.sh\n";
    }

    close(F);

    run('qsub', $alloc ? "-A $alloc" : undef,
                $queue ? "-q $queue" : undef,
                $pbs) unless $dry;

    $beg += $chunk;
    $k++;
}


sub min { $_[0] < $_[1] ? $_[0] : $_[1]; }
sub remove_dir { run("rm -rf $_[0]"); }
sub verify_dir { run("mkdir -p $_[0]");  }
sub run { system(@_) == 0 or confess("FAILED: ". join(" ", @_)); }
