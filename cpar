#! /usr/bin/env perl

use strict;
use Carp;
use Getopt::Long;

my $usage = <<"End_of_Usage";
Usage: $0 [options] qsub_walltime output_directory

Options:
        -A alloc         - project allocation for the qsub -A parameter
        -c chunk         - number of nodes per qsub job (D = 5)
        -dry             - dry run
        -n nodes         - max total nodes to use (D = 10)
        -N name          - job name 
        -q queue         - job queue for the qsub -q parameter
        -t threads       - number of threads each command uses (D = 1)
        -redo            - overwrite project directory

Examples:

  > for i in {1..60}; do echo "echo $i; sleep 60"; done | cpar -t 8 -j 5 -n 10 3:00 test

    This pipeline will launch 2 qsub jobs using a total of 10 nodes (240 cores).
    Each aprun line will execute (24/8=) 3 commands on the same node. 
    Each qsub job will use 5 nodes with (60/10*5/3=) 10 aprun lines.
    This means each node will be mapped to 2 aprun lines and thus 2 minutes.
    Given the qsub overhead, our 3-minute-long qsub jobs may be adequate. 

  > find /path/to/query -name *.fasta | parallel --dry-run blastall -a 6 -p blastp -d /NR/nr -i {} | cpar -t 6 1:00:00 output

    This pipeline will launch 1 hour jobs on no more than 10 nodes to
    blast every query file against the NR. A large number of query files
    will result in multiple sequential aprun lines on each node. So the
    qsub job length needs to be adjusted manually to reflect that.

End_of_Usage

my ($help, $alloc, $chunk, $dry, $name, $nproc, $nthread, $queue, $redo, $tmpdir);

GetOptions("h|help"    => \$help,
           "a|alloc=s" => \$alloc,
           "c|chunk=i" => \$chunk,
           "dry"       => \$dry,
           "n|np=i"    => \$nproc,
           "N|name=s"  => \$name,
           "q|queue=s" => \$queue, 
           "r|redo"    => \$redo,
           "t|nt=i"    => \$nthread,
	  ) or die("Error in command line arguments\n");

$help and die $usage;

$chunk   ||= 5;
$nproc   ||= 10;
$nthread ||= 1;
$name    ||= "cpar";

my $wall = shift @ARGV or die $usage;
my $dir  = shift @ARGV or die $usage;

-d $dir && !$redo and die "Directory '$dir' exists.\n\n$usage";
remove_dir($dir) if $redo;
verify_dir($dir);

my $cores_per_node = 24;

my @cmds = map { chomp; $_ } <STDIN>;

my $jobs_per_node = int($cores_per_node / $nthread);

my $i = 0;
my $cmd_i = 0;
while (@cmds) {
    $i++; $cmd_i++;
    my $jobfile = "$dir/node_$i.sh";
    open(F, ">$jobfile") or die "Could not open $jobfile";
    print F "#!/bin/bash\n\n";
    print F "host__=`hostname`\n\n";
    print F 'echo $host__ "BEG> " `date`'.">/dev/stderr\n\n";
    # print F "module swap PrgEnv-cray PrgEnv-gnu\n\n";

    for (my $j = 1; $j <= $jobs_per_node; $j++) {
        my $cmd = shift @cmds or last;
        print F "time ($cmd; echo $cmd_i >>cmds.done) > log_p$i\_j$j.txt &\n";
    }

    print F "wait\n\n";
    print F 'echo $host__ "END> " `date`'.">/dev/stderr\n\n";
    close(F);
    run("chmod a+x $jobfile");
}

my $tot = $i;
$nproc = min($nproc, $tot);

chdir($dir);
my $beg = 1;
my $k = 1;
while ($beg <= $tot) {
    # my $left  = $tot - $beg + 1;
    # my $remaining_chunks = $nproc - $k + 1;
    my $num   = $left - $tot -  / ($nproc/$chunk)
    
    my $end   = min($beg+$chunk-1, $tot);
    my $b_e   = $chunk > 1 ? "$beg-$end" : $beg;
    my $range = "$b_e/$tot";

    my $pbs   = "job$k.pbs";
    open(F, ">$pbs") or die "Could not open $pbs";
    print F "#!/bin/bash\n\n";

    print F "#PBS -l walltime=$wall\n";
    print F "#PBS -l mppwidth=24\n";
    print F "#PBS -N $name:$range\n";
    print F "#PBS -e $name-$b_e.".'$PBS_JOBID.err'."\n";
    print F "#PBS -o $name-$b_e.".'$PBS_JOBID.out'."\n\n";
    print F 'cd $PBS_O_WORKDIR'."\n\n";

    if ($chunk > 1) {
        for (my $i = $beg; $i <= $end; $i++) {
            print F "aprun ./node_$i.sh &\n";
        }
        print F "\nwait\n";
    } else {
        print F "aprun ./node_$beg.sh\n";
    }

    close(F);

    my @cmd = ('qsub', $alloc ? "-A $alloc" : undef,
               $queue ? "-q $queue" : undef,
               $pbs);

    if (!$dry) { system join(" ", @cmd); }

    $beg += $chunk;
    $k++;
}


sub min { $_[0] < $_[1] ? $_[0] : $_[1]; }
sub remove_dir { run("rm -rf $_[0]"); }
sub verify_dir { run("mkdir -p $_[0]");  }
sub run { system(@_) == 0 or confess("FAILED: ". join(" ", @_)); }
